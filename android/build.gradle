//import de.undercouch.gradle.tasks.download.Download
//buildscript {
//  // Buildscript is evaluated before everything else so we can't use getExtOrDefault
//  def kotlin_version = rootProject.ext.has('kotlinVersion') ? rootProject.ext.get('kotlinVersion') : project.properties['Tor_kotlinVersion']
//
//  repositories {
//    google()
//    jcenter()
//  }
//
//  dependencies {
//    classpath('com.android.tools.build:gradle:4.2.1')
//    // noinspection DifferentKotlinGradleVersion
//    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
//  }
//}
//
//apply plugin: 'com.android.library'
//apply plugin: 'kotlin-android'
//
//def getExtOrDefault(name) {
//  return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.properties['Tor_' + name]
//}
//
//def getExtOrIntegerDefault(name) {
//  return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties['Tor_' + name]).toInteger()
//}
//
//def localProps = new Properties()
//def localPropertiesFile = file("local.properties")
//if (localPropertiesFile.exists()) {
//  localProps.load(new InputStreamReader(new FileInputStream(localPropertiesFile), "UTF-8"))
//}
//def debugNativeLibraries = localProps.getProperty('NATIVE_DEBUG_ON', 'FALSE').toBoolean()
//
//def nodeModulesDir = new File(rootProject.projectDir, '../node_modules')
//def reactProperties = new Properties()
//def CMAKE_TOOLCHAIN_FILE = "-DCMAKE_TOOLCHAIN_FILE=${getNdkBuildFullPath()}/../build/cmake/android.toolchain.cmake"
//file("$nodeModulesDir/react-native/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }
//def reactNativeVersion = reactProperties.getProperty('VERSION_NAME')
//def FOLLY_VERSION = reactProperties.getProperty("FOLLY_VERSION")
//def BOOST_VERSION = reactProperties.getProperty("BOOST_VERSION")
//def DOUBLE_CONVERSION_VERSION = reactProperties.getProperty("DOUBLE_CONVERSION_VERSION")
//def GLOG_VERSION = reactProperties.getProperty("GLOG_VERSION")
//// We download various C++ open-source dependencies into downloads.
//// We then copy both the downloaded code and our custom makefiles and headers into third-party-ndk.
//// After that we build native code from src/main/jni with module path pointing at third-party-ndk.
//
//def downloadsDir = new File("$buildDir/downloads")
//def thirdPartyNdkDir = new File("$buildDir/third-party-ndk")
//
//def reactNative = new File("$projectDir/../node_modules/react-native")
//def reactNativeThirdParty = new File("$reactNative/ReactAndroid/src/main/jni/third-party")
//
//// You need to have following folders in this directory:
////   - boost_1_63_0
////   - double-conversion-1.1.6
////   - folly-deprecate-dynamic-initializer
////   - glog-0.3.5
//def dependenciesPath = System.getenv("REACT_NATIVE_DEPENDENCIES")
//
//// The Boost library is a very large download (>100MB).
//// If Boost is already present on your system, define the REACT_NATIVE_BOOST_PATH env variable
//// and the build will use that.
//def boostPath = dependenciesPath ?: System.getenv("REACT_NATIVE_BOOST_PATH")
//
//def follyReplaceContent = '''
//  ssize_t r;
//  do {
//    r = open(name, flags, mode);
//  } while (r == -1 && errno == EINTR);
//  return r;
//'''
//android {
//  compileSdkVersion getExtOrIntegerDefault('compileSdkVersion')
//  buildToolsVersion getExtOrDefault('buildToolsVersion')
//  defaultConfig {
//    minSdkVersion rootProject.ext.has('minSdkVersion') ? rootProject.ext.minSdkVersion : 16
//    targetSdkVersion getExtOrIntegerDefault('targetSdkVersion')
//    externalNativeBuild {
//      cmake {
//        cppFlags "-O2 -frtti -fexceptions -Wall -Wno-unused-variable -fstack-protector-all"
////        cppFlags "-fexceptions", "-frtti", "-std=c++1y", "-DONANDROID"
//        abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
//        arguments  "-DANDROID_STL=c++_shared",
//        "-DREACT_NATIVE_VERSION=${reactNativeVersion}",
//        "-DANDROID_TOOLCHAIN=clang",
//        "${CMAKE_TOOLCHAIN_FILE}",
//        "-DBOOST_VERSION=${BOOST_VERSION}",
//        "-DNODE_MODULES_DIR=${nodeModulesDir}"
//      }
//    }
//  }
//    configurations {
//        all*.exclude module: 'fbjni-java-only'
//    }
//    packagingOptions {
//        pickFirst 'lib/*/libfbjni.so'
//        pickFirst 'lib/*/libc++_shared.so'
//    }
//  externalNativeBuild {
//    cmake {
//      path "CMakeLists.txt"
//    }
//  }
//  buildTypes {
//    release {
//      minifyEnabled false
//    }
//  }
//  lintOptions {
//    disable 'GradleCompatible'
//  }
//  compileOptions {
//    sourceCompatibility JavaVersion.VERSION_1_8
//    targetCompatibility JavaVersion.VERSION_1_8
//  }
// // dependencies {
// //   implementation 'com.facebook.fbjni:fbjni:0.2.2'
// // }
//  configurations {
//    extractJNI
//    extractHeaders
//    extractSO
//  }
////  applicationVariants.all { variant ->
////    variant.getruntimeconfiguration().exclude module: 'fbjni-java-only-0.0.3.jar'
////  }
//}
//
////configurations {
////  all*.exclude module: 'fbjni-java-only'
////}
//configurations.all {
//  resolutionStrategy.dependencySubstitution {
//    substitute module('com.facebook.fbjni:fbjni-java-only:0.0.3') with module('com.facebook.fbjni:fbjni:0.2.2')
//  }
//}
//repositories {
//  mavenCentral()
//  jcenter()
//  google()
//
//  def found = false
//  def defaultDir = null
//  def androidSourcesName = 'React Native sources'
//
//  if (rootProject.ext.has('reactNativeAndroidRoot')) {
//    defaultDir = rootProject.ext.get('reactNativeAndroidRoot')
//  } else {
//    defaultDir = new File(
//      projectDir,
//      '/../../../node_modules/react-native/android'
//    )
//  }
//
//  if (defaultDir.exists()) {
//    maven {
//      url defaultDir.toString()
//      name androidSourcesName
//    }
//
//    logger.info(":${project.name}:reactNativeAndroidRoot ${defaultDir.canonicalPath}")
//    found = true
//  } else {
//    def parentDir = rootProject.projectDir
//
//    1.upto(5, {
//      if (found) return true
//      parentDir = parentDir.parentFile
//
//      def androidSourcesDir = new File(
//        parentDir,
//        'node_modules/react-native'
//      )
//
//      def androidPrebuiltBinaryDir = new File(
//        parentDir,
//        'node_modules/react-native/android'
//      )
//
//      if (androidPrebuiltBinaryDir.exists()) {
//        maven {
//          url androidPrebuiltBinaryDir.toString()
//          name androidSourcesName
//        }
//
//        logger.info(":${project.name}:reactNativeAndroidRoot ${androidPrebuiltBinaryDir.canonicalPath}")
//        found = true
//      } else if (androidSourcesDir.exists()) {
//        maven {
//          url androidSourcesDir.toString()
//          name androidSourcesName
//        }
//
//        logger.info(":${project.name}:reactNativeAndroidRoot ${androidSourcesDir.canonicalPath}")
//        found = true
//      }
//    })
//  }
//
//  if (!found) {
//    throw new GradleException(
//      "${project.name}: unable to locate React Native android sources. " +
//        "Ensure you have you installed React Native as a dependency in your project and try again."
//    )
//  }
//}
//
//def kotlin_version = getExtOrDefault('kotlinVersion')
//
//static def getNdkBuildName() {
//    return "ndk-build"
//}
//def findNdkBuildFullPath() {
//  // we allow to provide full path to ndk-build tool
//  if (hasProperty("ndk.command")) {
//    return property("ndk.command")
//  }
//  // or just a path to the containing directory
//  if (hasProperty("ndk.path")) {
//    def ndkDir = property("ndk.path")
//    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
//  }
//
//  if (System.getenv("ANDROID_NDK") != null) {
//    def ndkDir = System.getenv("ANDROID_NDK")
//    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
//  }
//
//  if (hasProperty("ndkDirectory")) {
//    def ndkDir = android.ndkDirectory ? android.ndkDirectory.absolutePath : null
//
//    if (ndkDir) {
//      return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
//    }
//  }
//
//  def Properties properties = new Properties()
//  if (rootProject.file("local.properties").exists()) {
//    properties.load(project.rootProject.file("local.properties").newDataInputStream())
//    def ndkDir=properties.getProperty("ndk.dir", null);
//    if(ndkDir)
//    {
//      return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
//    }
//  }
//  return null
//}
//def getNdkBuildFullPath() {
//  def ndkBuildFullPath = findNdkBuildFullPath()
//  if (ndkBuildFullPath == null) {
//    throw new GradleScriptException(
//      "ndk-build binary cannot be found, check if you've set " +
//        "\$ANDROID_NDK environment variable correctly or if ndk.dir is " +
//        "setup in local.properties",
//      null)
//  }
//  if (!new File(ndkBuildFullPath).canExecute()) {
//    throw new GradleScriptException(
//      "ndk-build binary " + ndkBuildFullPath + " doesn't exist or isn't executable.\n" +
//        "Check that the \$ANDROID_NDK environment variable, or ndk.dir in local.properties, is set correctly.\n" +
//        "(On Windows, make sure you escape backslashes in local.properties or use forward slashes, e.g. C:\\\\ndk or C:/ndk rather than C:\\ndk)",
//      null)
//  }
//  return ndkBuildFullPath
//}
//
//dependencies {
//  // noinspection GradleDynamicVersion
//  //api 'com.facebook.react:react-native:+'
//  //def rnAAR = fileTree(".").matching({ it.include "**/**/*.aar" }).singleFile
//  //extractJNI(files(rnAAR))
//  //implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
//  //compileOnly files('libs/sifir_android.aar')
//  // noinspection GradleDynamicVersion
//  api 'com.facebook.react:react-native:+'
//  implementation 'com.facebook.fbjni:fbjni:0.2.2'
//
//  extractHeaders("com.facebook.fbjni:fbjni:0.2.2:headers")
//  extractSO("com.facebook.fbjni:fbjni:0.2.2")
//
//  def rnAAR = fileTree("${rootDir}/../node_modules/react-native/android").matching({ it.include "**/**/*.aar" }).singleFile
//  def jscAAR = fileTree("${rootDir}/../node_modules/jsc-android/dist/org/webkit/android-jsc").matching({ it.include "**/**/*.aar" }).singleFile
//  extractSO(files(rnAAR, jscAAR))
//
//}
//task extractAARHeaders {
//  doLast {
//    configurations.extractHeaders.files.each {
//      def file = it.absoluteFile
//      def packageName = file.name.tokenize('-')[0]
//      copy {
//        from zipTree(file)
//        into "$reactNative/ReactAndroid/src/main/jni/first-party/$packageName/headers"
//        include "**/*.h"
//      }
//    }
//  }
//}
//
//task extractSOFiles {
//  doLast {
//    configurations.extractSO.files.each {
//      def file = it.absoluteFile
//      def packageName = file.name.tokenize('-')[0]
//      copy {
//        from zipTree(file)
//        into "$reactNative/ReactAndroid/src/main/jni/first-party/$packageName/"
//        include "jni/**/*.so"
//      }
//    }
//  }
//}
//task createNativeDepsDirectories {
//  downloadsDir.mkdirs()
//  thirdPartyNdkDir.mkdirs()
//}
//
//task downloadBoost(dependsOn: createNativeDepsDirectories, type: Download) {
//  src("https://github.com/react-native-community/boost-for-react-native/releases/download/v${BOOST_VERSION.replace("_", ".")}-0/boost_${BOOST_VERSION}.tar.gz")
//  onlyIfNewer(true)
//  overwrite(false)
//  dest(new File(downloadsDir, "boost_${BOOST_VERSION}.tar.gz"))
//}
//
//task prepareBoost(dependsOn: boostPath ? [] : [downloadBoost], type: Copy) {
//  from(boostPath ?: tarTree(resources.gzip(downloadBoost.dest)))
//  from("$reactNativeThirdParty/boost/Android.mk")
//  include("Android.mk", "boost_${BOOST_VERSION}/boost/**/*.hpp", "boost/boost/**/*.hpp")
//  includeEmptyDirs = false
//  into("$thirdPartyNdkDir/boost")
//  doLast {
//    file("$thirdPartyNdkDir/boost/boost").renameTo("$thirdPartyNdkDir/boost/boost_${BOOST_VERSION}")
//  }
//}
//
//task downloadDoubleConversion(dependsOn: createNativeDepsDirectories, type: Download) {
//  src("https://github.com/google/double-conversion/archive/v${DOUBLE_CONVERSION_VERSION}.tar.gz")
//  onlyIfNewer(true)
//  overwrite(false)
//  dest(new File(downloadsDir, "double-conversion-${DOUBLE_CONVERSION_VERSION}.tar.gz"))
//}
//
//task prepareDoubleConversion(dependsOn: dependenciesPath ? [] : [downloadDoubleConversion], type: Copy) {
//  from(dependenciesPath ?: tarTree(downloadDoubleConversion.dest))
//  from("$reactNativeThirdParty/double-conversion/Android.mk")
//  include("double-conversion-${DOUBLE_CONVERSION_VERSION}/src/**/*", "Android.mk")
//  filesMatching("*/src/**/*", { fname -> fname.path = "double-conversion/${fname.name}" })
//  includeEmptyDirs = false
//  into("$thirdPartyNdkDir/double-conversion")
//}
//
//task downloadFolly(dependsOn: createNativeDepsDirectories, type: Download) {
//  src("https://github.com/facebook/folly/archive/v${FOLLY_VERSION}.tar.gz")
//  onlyIfNewer(true)
//  overwrite(false)
//  dest(new File(downloadsDir, "folly-${FOLLY_VERSION}.tar.gz"))
//}
//
//task prepareFolly(dependsOn: dependenciesPath ? [] : [downloadFolly], type: Copy) {
//  from(dependenciesPath ?: tarTree(downloadFolly.dest))
//  from("$reactNativeThirdParty/folly/Android.mk")
//  include("folly-${FOLLY_VERSION}/folly/**/*", "Android.mk")
//  eachFile { fname -> fname.path = (fname.path - "folly-${FOLLY_VERSION}/") }
//  // Fixes problem with Folly failing to build on certain systems. See
//  // https://github.com/software-mansion/react-native-reanimated/issues/1024
//  filter { line -> line.replaceAll('return int\\(wrapNoInt\\(open, name, flags, mode\\)\\);', follyReplaceContent) }
//  includeEmptyDirs = false
//  into("$thirdPartyNdkDir/folly")
//}
//
//task downloadGlog(dependsOn: createNativeDepsDirectories, type: Download) {
//  src("https://github.com/google/glog/archive/v${GLOG_VERSION}.tar.gz")
//  onlyIfNewer(true)
//  overwrite(false)
//  dest(new File(downloadsDir, "glog-${GLOG_VERSION}.tar.gz"))
//}
//
//// Prepare glog sources to be compiled, this task will perform steps that normally should've been
//// executed by automake. This way we can avoid dependencies on make/automake
//task prepareGlog(dependsOn: dependenciesPath ? [] : [downloadGlog], type: Copy) {
//  from(dependenciesPath ?: tarTree(downloadGlog.dest))
//  from("$reactNativeThirdParty/glog/")
//  include("glog-${GLOG_VERSION}/src/**/*", "Android.mk", "config.h")
//  includeEmptyDirs = false
//  filesMatching("**/*.h.in") {
//    filter(ReplaceTokens, tokens: [
//      ac_cv_have_unistd_h           : "1",
//      ac_cv_have_stdint_h           : "1",
//      ac_cv_have_systypes_h         : "1",
//      ac_cv_have_inttypes_h         : "1",
//      ac_cv_have_libgflags          : "0",
//      ac_google_start_namespace     : "namespace google {",
//      ac_cv_have_uint16_t           : "1",
//      ac_cv_have_u_int16_t          : "1",
//      ac_cv_have___uint16           : "0",
//      ac_google_end_namespace       : "}",
//      ac_cv_have___builtin_expect   : "1",
//      ac_google_namespace           : "google",
//      ac_cv___attribute___noinline  : "__attribute__ ((noinline))",
//      ac_cv___attribute___noreturn  : "__attribute__ ((noreturn))",
//      ac_cv___attribute___printf_4_5: "__attribute__((__format__ (__printf__, 4, 5)))"
//    ])
//    it.path = (it.name - ".in")
//  }
//  into("$thirdPartyNdkDir/glog")
//
//  doLast {
//    copy {
//      from(fileTree(dir: "$thirdPartyNdkDir/glog", includes: ["stl_logging.h", "logging.h", "raw_logging.h", "vlog_is_on.h", "**/src/glog/log_severity.h"]).files)
//      includeEmptyDirs = false
//      into("$thirdPartyNdkDir/glog/exported/glog")
//    }
//  }
//}
//task extractJNIFiles {
//  doLast {
//    configurations.extractJNI.files.each {
//      def file = it.absoluteFile
//
//      copy {
//        from zipTree(file)
//        into "$buildDir/$file.name"
//        include "jni/**/*"
//      }
//    }
//  }
//}
//
//
//task downloadNdkBuildDependencies {
//  if (!boostPath) {
//    dependsOn(downloadBoost)
//  }
//  dependsOn(downloadDoubleConversion)
//  dependsOn(downloadFolly)
////  dependsOn(downloadGlog)
//}
//
////task prepareThirdPartyNdkHeaders(dependsOn:[downloadNdkBuildDependencies, prepareBoost, prepareDoubleConversion, prepareFolly, prepareGlog]) {
////}
//task prepareThirdPartyNdkHeaders(dependsOn:[downloadNdkBuildDependencies, prepareBoost, prepareDoubleConversion, prepareFolly]) {
//}
//
//tasks.whenTaskAdded { task ->
//  if (task.name.contains('externalNativeBuild')) {
//    task.dependsOn(prepareThirdPartyNdkHeaders)
//    extractAARHeaders.dependsOn(prepareThirdPartyNdkHeaders)
//    extractSOFiles.dependsOn(prepareThirdPartyNdkHeaders)
//    task.dependsOn(extractAARHeaders)
//    task.dependsOn(extractSOFiles)
//  }
//}
//
////tasks.whenTaskAdded { task ->
////  if (task.name.contains('externalNativeBuild')) {
////    task.dependsOn(extractJNIFiles)
////  }
////}
////
////// Fix clean and arr compile deps
////// https://github.com/ammarahm-ed/react-native-jsi-template/issues/1#issuecomment-930287524
//tasks.whenTaskAdded { task ->
//  if (task.name.contains('generateJsonModelDebug') || task.name.contains('externalNativeBuild')) {
//    task.dependsOn(extractJNIFiles);
//  }
//
//  if (task.name.contains('generateJsonModelRelease')) {
//    task.dependsOn(extractJNIFiles)
////    task.dependsOn(extractJNIFilesForRelease)
//  }
//}
//
//// ---
import java.nio.file.Paths

import de.undercouch.gradle.tasks.download.Download
import org.apache.tools.ant.taskdefs.condition.Os
import org.apache.tools.ant.filters.ReplaceTokens

def localProps = new Properties()
def localPropertiesFile = file("local.properties")
if (localPropertiesFile.exists()) {
  localProps.load(new InputStreamReader(new FileInputStream(localPropertiesFile), "UTF-8"))
}
def debugNativeLibraries = localProps.getProperty('NATIVE_DEBUG_ON', 'FALSE').toBoolean()

def nodeModulesDir = new File(rootProject.projectDir, '../node_modules')
def reactProperties = new Properties()
file("$nodeModulesDir/react-native/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }
def reactNativeVersion = reactProperties.getProperty('VERSION_NAME')

def BOOST_VERSION = reactProperties.getProperty("BOOST_VERSION")
def DOUBLE_CONVERSION_VERSION = reactProperties.getProperty("DOUBLE_CONVERSION_VERSION")
def FOLLY_VERSION = reactProperties.getProperty("FOLLY_VERSION")
def GLOG_VERSION = reactProperties.getProperty("GLOG_VERSION")

// We download various C++ open-source dependencies into downloads.
// We then copy both the downloaded code and our custom makefiles and headers into third-party-ndk.
// After that we build native code from src/main/jni with module path pointing at third-party-ndk.

def downloadsDir = new File("$buildDir/downloads")
def thirdPartyNdkDir = new File("$buildDir/third-party-ndk")

def reactNative = new File("$projectDir/../node_modules/react-native")
def reactNativeThirdParty = new File("$reactNative/ReactAndroid/src/main/jni/third-party")

// You need to have following folders in this directory:
//   - boost_1_63_0
//   - double-conversion-1.1.6
//   - folly-deprecate-dynamic-initializer
//   - glog-0.3.5
def dependenciesPath = System.getenv("REACT_NATIVE_DEPENDENCIES")

// The Boost library is a very large download (>100MB).
// If Boost is already present on your system, define the REACT_NATIVE_BOOST_PATH env variable
// and the build will use that.
def boostPath = dependenciesPath ?: System.getenv("REACT_NATIVE_BOOST_PATH")

def follyReplaceContent = '''
  ssize_t r;
  do {
    r = open(name, flags, mode);
  } while (r == -1 && errno == EINTR);
  return r;
'''

def CMAKE_TOOLCHAIN_FILE = "-DCMAKE_TOOLCHAIN_FILE=${getNdkBuildFullPath()}/../build/cmake/android.toolchain.cmake"

buildscript {
//  // Buildscript is evaluated before everything else so we can't use getExtOrDefault
  def kotlin_version = rootProject.ext.has('kotlinVersion') ? rootProject.ext.get('kotlinVersion') : project.properties['Tor_kotlinVersion']
  repositories {
    google()
    jcenter()
  }

  dependencies {
    classpath 'com.android.tools.build:gradle:4.1.3'
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    classpath 'de.undercouch:gradle-download-task:4.0.4'
  }
}

apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'

def getExtOrDefault(name) {
  return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.properties['Tor_' + name]
}

def getExtOrIntegerDefault(name) {
  return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties['Tor_' + name]).toInteger()
}

android {
  buildFeatures {
    prefab true
  }

  compileSdkVersion getExtOrIntegerDefault('compileSdkVersion')
  buildToolsVersion getExtOrDefault('buildToolsVersion')
  defaultConfig {
    minSdkVersion 16
    targetSdkVersion getExtOrIntegerDefault('targetSdkVersion')
    versionCode 1
    versionName "1.0"

    externalNativeBuild {
      cmake {
        cppFlags "-O2 -frtti -fexceptions -Wall -Wno-unused-variable -fstack-protector-all"
        abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
        arguments "-DANDROID_STL=c++_shared",
          "-DREACT_NATIVE_VERSION=${reactNativeVersion}",
          "-DANDROID_TOOLCHAIN=clang",
          "${CMAKE_TOOLCHAIN_FILE}",
          "-DBOOST_VERSION=${BOOST_VERSION}",
          "-DNODE_MODULES_DIR=${nodeModulesDir}"
      }
    }

  }

  externalNativeBuild {
    cmake {
      path "CMakeLists.txt"
    }
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }
  lintOptions {
    disable 'GradleCompatible'
  }
  configurations {
    extractHeaders
    extractSO
  }
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
  sourceSets {
      main {
          // let gradle pack the sifir lib
          jniLibs.srcDirs = ['./libs']
      }
  }
}

task createNativeDepsDirectories {
  downloadsDir.mkdirs()
  thirdPartyNdkDir.mkdirs()
}

task downloadBoost(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/react-native-community/boost-for-react-native/releases/download/v${BOOST_VERSION.replace("_", ".")}-0/boost_${BOOST_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "boost_${BOOST_VERSION}.tar.gz"))
}

task prepareBoost(dependsOn: boostPath ? [] : [downloadBoost], type: Copy) {
  from(boostPath ?: tarTree(resources.gzip(downloadBoost.dest)))
  from("$reactNativeThirdParty/boost/Android.mk")
  include("Android.mk", "boost_${BOOST_VERSION}/boost/**/*.hpp", "boost/boost/**/*.hpp")
  includeEmptyDirs = false
  into("$thirdPartyNdkDir/boost")
  doLast {
    file("$thirdPartyNdkDir/boost/boost").renameTo("$thirdPartyNdkDir/boost/boost_${BOOST_VERSION}")
  }
}

task downloadDoubleConversion(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/google/double-conversion/archive/v${DOUBLE_CONVERSION_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "double-conversion-${DOUBLE_CONVERSION_VERSION}.tar.gz"))
}

task prepareDoubleConversion(dependsOn: dependenciesPath ? [] : [downloadDoubleConversion], type: Copy) {
  from(dependenciesPath ?: tarTree(downloadDoubleConversion.dest))
  from("$reactNativeThirdParty/double-conversion/Android.mk")
  include("double-conversion-${DOUBLE_CONVERSION_VERSION}/src/**/*", "Android.mk")
  filesMatching("*/src/**/*", { fname -> fname.path = "double-conversion/${fname.name}" })
  includeEmptyDirs = false
  into("$thirdPartyNdkDir/double-conversion")
}

task downloadFolly(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/facebook/folly/archive/v${FOLLY_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "folly-${FOLLY_VERSION}.tar.gz"))
}

task prepareFolly(dependsOn: dependenciesPath ? [] : [downloadFolly], type: Copy) {
  from(dependenciesPath ?: tarTree(downloadFolly.dest))
  from("$reactNativeThirdParty/folly/Android.mk")
  include("folly-${FOLLY_VERSION}/folly/**/*", "Android.mk")
  eachFile { fname -> fname.path = (fname.path - "folly-${FOLLY_VERSION}/") }
  // Fixes problem with Folly failing to build on certain systems. See
  // https://github.com/software-mansion/react-native-reanimated/issues/1024
  filter { line -> line.replaceAll('return int\\(wrapNoInt\\(open, name, flags, mode\\)\\);', follyReplaceContent) }
  includeEmptyDirs = false
  into("$thirdPartyNdkDir/folly")
}

task downloadGlog(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/google/glog/archive/v${GLOG_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "glog-${GLOG_VERSION}.tar.gz"))
}

// Prepare glog sources to be compiled, this task will perform steps that normally should've been
// executed by automake. This way we can avoid dependencies on make/automake
task prepareGlog(dependsOn: dependenciesPath ? [] : [downloadGlog], type: Copy) {
  from(dependenciesPath ?: tarTree(downloadGlog.dest))
  from("$reactNativeThirdParty/glog/")
  include("glog-${GLOG_VERSION}/src/**/*", "Android.mk", "config.h")
  includeEmptyDirs = false
  filesMatching("**/*.h.in") {
    filter(ReplaceTokens, tokens: [
      ac_cv_have_unistd_h           : "1",
      ac_cv_have_stdint_h           : "1",
      ac_cv_have_systypes_h         : "1",
      ac_cv_have_inttypes_h         : "1",
      ac_cv_have_libgflags          : "0",
      ac_google_start_namespace     : "namespace google {",
      ac_cv_have_uint16_t           : "1",
      ac_cv_have_u_int16_t          : "1",
      ac_cv_have___uint16           : "0",
      ac_google_end_namespace       : "}",
      ac_cv_have___builtin_expect   : "1",
      ac_google_namespace           : "google",
      ac_cv___attribute___noinline  : "__attribute__ ((noinline))",
      ac_cv___attribute___noreturn  : "__attribute__ ((noreturn))",
      ac_cv___attribute___printf_4_5: "__attribute__((__format__ (__printf__, 4, 5)))"
    ])
    it.path = (it.name - ".in")
  }
  into("$thirdPartyNdkDir/glog")

  doLast {
    copy {
      from(fileTree(dir: "$thirdPartyNdkDir/glog", includes: ["stl_logging.h", "logging.h", "raw_logging.h", "vlog_is_on.h", "**/src/glog/log_severity.h"]).files)
      includeEmptyDirs = false
      into("$thirdPartyNdkDir/glog/exported/glog")
    }
  }
}

static def getNdkBuildName() {
  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    return "ndk-build.cmd"
  } else {
    return "ndk-build"
  }
}

def findNdkBuildFullPath() {
  // we allow to provide full path to ndk-build tool
  if (hasProperty("ndk.command")) {
    return property("ndk.command")
  }
  // or just a path to the containing directory
  if (hasProperty("ndk.path")) {
    def ndkDir = property("ndk.path")
    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
  }

  if (System.getenv("ANDROID_NDK") != null) {
    def ndkDir = System.getenv("ANDROID_NDK")
    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
  }

  if (hasProperty("ndkDirectory")) {
    def ndkDir = android.ndkDirectory ? android.ndkDirectory.absolutePath : null

    if (ndkDir) {
      return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
    }
  }

  def Properties properties = new Properties()
  if (rootProject.file("local.properties").exists()) {
    properties.load(project.rootProject.file("local.properties").newDataInputStream())
    def ndkDir=properties.getProperty("ndk.dir", null);
    if(ndkDir)
    {
      return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
    }
  }
  return null
}

def getNdkBuildFullPath() {
  def ndkBuildFullPath = findNdkBuildFullPath()
  if (ndkBuildFullPath == null) {
    throw new GradleScriptException(
      "ndk-build binary cannot be found, check if you've set " +
        "\$ANDROID_NDK environment variable correctly or if ndk.dir is " +
        "setup in local.properties",
      null)
  }
  if (!new File(ndkBuildFullPath).canExecute()) {
    throw new GradleScriptException(
      "ndk-build binary " + ndkBuildFullPath + " doesn't exist or isn't executable.\n" +
        "Check that the \$ANDROID_NDK environment variable, or ndk.dir in local.properties, is set correctly.\n" +
        "(On Windows, make sure you escape backslashes in local.properties or use forward slashes, e.g. C:\\\\ndk or C:/ndk rather than C:\\ndk)",
      null)
  }
  return ndkBuildFullPath
}

task extractAARHeaders {
  doLast {
    configurations.extractHeaders.files.each {
      def file = it.absoluteFile
      def packageName = file.name.tokenize('-')[0]
      copy {
        from zipTree(file)
        into "$reactNative/ReactAndroid/src/main/jni/first-party/$packageName/headers"
        include "**/*.h"
      }
    }
  }
}

task extractSOFiles {
  doLast {
    configurations.extractSO.files.each {
      def file = it.absoluteFile
      def packageName = file.name.tokenize('-')[0]
      copy {
        from zipTree(file)
        into "$reactNative/ReactAndroid/src/main/jni/first-party/$packageName/"
        include "jni/**/*.so"
      }
    }
  }
}

task downloadNdkBuildDependencies {
  if (!boostPath) {
    dependsOn(downloadBoost)
  }
  dependsOn(downloadDoubleConversion)
  dependsOn(downloadFolly)
  dependsOn(downloadGlog)
}

task prepareThirdPartyNdkHeaders(dependsOn:[downloadNdkBuildDependencies, prepareBoost, prepareDoubleConversion, prepareFolly, prepareGlog]) {
}

tasks.whenTaskAdded { task ->
  if (task.name.contains('externalNativeBuild')) {
    task.dependsOn(prepareThirdPartyNdkHeaders)
    extractAARHeaders.dependsOn(prepareThirdPartyNdkHeaders)
    extractSOFiles.dependsOn(prepareThirdPartyNdkHeaders)
    task.dependsOn(extractAARHeaders)
    task.dependsOn(extractSOFiles)
  }
}

repositories {
  mavenCentral()
  jcenter()
  google()

  def found = false
  def defaultDir = null
  def androidSourcesName = 'React Native sources'

  if (rootProject.ext.has('reactNativeAndroidRoot')) {
    defaultDir = rootProject.ext.get('reactNativeAndroidRoot')
  } else {
    defaultDir = new File(
      projectDir,
      '/../../../node_modules/react-native/android'
    )
  }

  if (defaultDir.exists()) {
    maven {
      url defaultDir.toString()
      name androidSourcesName
    }

    logger.info(":${project.name}:reactNativeAndroidRoot ${defaultDir.canonicalPath}")
    found = true
  } else {
    def parentDir = rootProject.projectDir

    1.upto(5, {
      if (found) return true
      parentDir = parentDir.parentFile

      def androidSourcesDir = new File(
        parentDir,
        'node_modules/react-native'
      )

      def androidPrebuiltBinaryDir = new File(
        parentDir,
        'node_modules/react-native/android'
      )

      if (androidPrebuiltBinaryDir.exists()) {
        maven {
          url androidPrebuiltBinaryDir.toString()
          name androidSourcesName
        }

        logger.info(":${project.name}:reactNativeAndroidRoot ${androidPrebuiltBinaryDir.canonicalPath}")
        found = true
      } else if (androidSourcesDir.exists()) {
        maven {
          url androidSourcesDir.toString()
          name androidSourcesName
        }

        logger.info(":${project.name}:reactNativeAndroidRoot ${androidSourcesDir.canonicalPath}")
        found = true
      }
    })
  }

  if (!found) {
    throw new GradleException(
      "${project.name}: unable to locate React Native android sources. " +
        "Ensure you have you installed React Native as a dependency in your project and try again."
    )
  }
}
def kotlin_version = getExtOrDefault('kotlinVersion')

dependencies {
  // noinspection GradleDynamicVersion
  api 'com.facebook.react:react-native:+'
  implementation 'com.facebook.fbjni:fbjni:0.2.2'

  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
  extractHeaders("com.facebook.fbjni:fbjni:0.2.2:headers")
  extractSO("com.facebook.fbjni:fbjni:0.2.2")

  def rnAAR = fileTree("${rootDir}/../node_modules/react-native/android").matching({ it.include "**/**/*.aar" }).singleFile
  def jscAAR = fileTree("${rootDir}/../node_modules/jsc-android/dist/org/webkit/android-jsc").matching({ it.include "**/**/*.aar" }).singleFile
  extractSO(files(rnAAR, jscAAR))
}
